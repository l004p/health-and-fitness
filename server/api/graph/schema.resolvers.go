package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"server/api/graph/model"
	"server/core"
	"server/services/user"
	"strconv"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	//panic(fmt.Errorf("not implemented: CreateUser - createUser"))
	user := core.User{
		Username:     input.Username,
		UserPassword: input.Password,
		UserEmail:    input.UserEmail,
		FirstName:    input.FirstName,
		LastName:     input.LastName,
	}
	user, err := userservice.CreateUser(r.Repo, ctx, user)
	if err != nil {
		return nil, err
	}
	gqlUser := &model.User{
		UserID:    strconv.FormatInt(int64(user.UserID), 10),
		Username:  user.Username,
		UserEmail: user.UserEmail,
		FirstName: user.FirstName,
		LastName:  user.LastName,
	}
	return gqlUser, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	//panic(fmt.Errorf("not implemented: Users - users"))
	user1 := &model.User{
		UserID:    strconv.FormatInt(int64(1), 10),
		Username:  "testName",
		FirstName: "Justin",
		LastName:  "Foley",
	}
	user2 := &model.User{
		UserID:    strconv.FormatInt(int64(2), 10),
		Username:  "testName2",
		FirstName: "Jessica",
		LastName:  "Davies",
	}
	var users []*model.User
	users = append(users, user1, user2)
	userservice.TestFunction(r.Repo, ctx)
	return users, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
